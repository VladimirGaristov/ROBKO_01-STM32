\chapter{Софтуер на микроконтролера}
\label{firmware_chapter}
%Уточни от кои файлове се състои програмата
\indent{}Софтуерът на микроконтролера е изграден на базата на Low-Layer Drivers (LL) и Hardware Abstraction Layer (HAL) библиотеките, предоставени безплатно от ST Microelectronics. Те, на свой ред, разчитат на Cortex Microcontroller Software Interface Standard (CMSIS) - API на ARM Holdings.\\
\indent{}
CMSIS отговаря за спецификата на конкретния модел микроконтролер. Дефинира като предпроцесорни макроси адресните пространства на различните модули и дефинира структури от данни, съответстващи на значението на отделните адреси в тези пространства.
\cite{mcu_prog_man}
Това позволява една и съща програма да се изпълнява на различни микроконтролери и освобождава програмиста от бремето да борави с конкретни адреси от паметта. Достъпът до дадедн модул на микроконтролера се извършва по следния начин: Макросът, отговарящ за началото на адресното пространство на този модул, се третира като указател към структура от тип, специфичен за този модул. Полетата на структурата съответстват на регистрите на модула. За мигриране на програмата към друг Cortex M4 микроконтролер просто се сменя заглавния файл, съдържащ физическите адреси от паметта.\\
\indent{}
Библиотеките LL и HAL на STM добавят слой на абстракция над CMSIS и предоставят полезни функционалности. При работа с тези библиотеки програмистът не настройва модулите на микроконтролера на ниво регистри, а подава параметри на библиотечните функции, които извършват операции с регистрите.
\cite{ll_hal_man}
\section{Основна функция}
\begin{figure}[!htb]
    \centering
    \begin{tikzpicture}[node distance=1.5cm]
        \node (start) [startstop] {Начало};
        \node (ll_init) [process, below of = start] {LL\_Init()};
        \node (sysclk) [process, below of = ll_init] {SystemClock\_Config()};
        \node (gpio) [process, below of = sysclk] {MX\_GPIO\_Init()};
        \node (dma) [process, below of = gpio] {Configure\_DMA()};
        \node (adc_init) [process, below of = dma] {MX\_ADC1\_Init()};
        \node (usart) [process, right of = start, xshift = 65mm] {MX\_USART1\_UART\_Init()};
        \node (adc_act) [process, below of = usart] {Activate\_ADC()};
        \node (dwt) [process, below of = adc_act] {DWT\_Init()};
        \node (adc_start) [process, below of = dwt] {LL\_ADC\_REG\_StartConversion()};
        \node (robko_en) [process, below of = adc_start] {Enable\_Robko()};
        \node (stop_all) [process, below of = robko_en] {stop\_motor(ALL)};
        \node (sw1) [io, below of = stop_all, xshift = -30mm, yshift = -5mm] {Прочитане на SW1};
        \node (mode) [decision, below of = sw1, inner sep = 0.1cm, yshift = -15mm] {\makecell{Ръчно\\управление?}};
        \node (manual) [process, below of = mode, xshift = -35mm, yshift = -5mm] {manual\_control()};
        \node (remote) [process, below of = mode, xshift = 35mm, yshift = -5mm] {remote\_control()};
        \node (leds) [process, below of = mode, yshift = -25mm] {set\_LEDs()};
        \node (wait) [process, below of = leds] {Изчакване};
        \draw [arrow] (start) -- (ll_init);
        \draw [arrow] (ll_init) -- (sysclk);
        \draw [arrow] (sysclk) -- (gpio);
        \draw [arrow] (gpio) -- (dma);
        \draw [arrow] (dma) -- (adc_init);
        \draw [arrow] (adc_init) -| ([shift = {(-15mm,0mm)}] usart.west) -- (usart);
        \draw [arrow] (usart) -- (adc_act);
        \draw [arrow] (adc_act) -- (dwt);
        \draw [arrow] (dwt) -- (adc_start);
        \draw [arrow] (adc_start) -- (robko_en);
        \draw [arrow] (robko_en) -- (stop_all);
        \draw [arrow] ([shift = {(25mm, 0mm)}] stop_all) |- (sw1);
        \draw [arrow] (sw1) -- (mode);
        \draw [arrow] (mode) -| node [anchor = south west] {Да} (manual);
        \draw [arrow] (mode) -| node [anchor = south east] {Не} (remote);
        \draw [arrow] (manual) |- (leds);
        \draw [arrow] (remote) |- (leds);
        \draw [arrow] (leds) -- (wait);
        \draw [arrow] (wait) -| ([shift = {(-30mm, 0mm)}] sw1.west) -- (sw1);
    \end{tikzpicture}
    \caption{Блокова схема на функция main()}
    \label{fig:flch_main}
\end{figure}
При стартиране на контролера първо се инициализират програмният брояч, стековият указател и области от паметта, в една от които се зареждат адресите на функциите, които се изпълняват при прекъсвания. Настройва се основният тактов сигнал с честота 40MHz. Този синхронизиращ сигнал се получава от вътрешен осцилатор с честота 4MHz умножена по 20 от PLL и разделена на 2. Извършва се инициализация на библиотеката на средата за изпълнение (C runtime library), след което се изпълнява функцията main(), чиято блок схема е показана на фигура \ref{fig:flch_main}. Тялото на цикълът в долната част на схемата е отделен във функцията check\_mode(), която се извиква в безкраен цикъл в main(). Функциите, чиито имена започват с MX, и функцията SystemClock\_Config() са генерирани от CubeMX - програма на ST Microelectronics, която генерира инициализиращ код спрямо настройки, въведени в графична среда. Функциите ADC\_Init() и Configure\_DMA() са взети от примерни програми, предоставени безплатно от ST Microelectronics, и променени спрямо нуждите на текущата разработка.\\
\indent{}
main() функцията се състои от инициализиращи и конфигуриращи функции и основен цикъл. Тази функция никога не трябва да завърши. Ако това все пак се случи, контролерът влиза в безкраен цикъл, който не изпълнява други инструкции.\\
\indent{}
Първата от инициализиращите функции е LL\_init(). В нея се настройват приоритетите на различните прекъсвания. В програмата се използва само прекъсването, генерирано от получаване на дума в USART модула. Функцията, която се изпълнява при получаването на това прекъсване, се разглежда в точка \ref{cmd_recv_section}\\
\indent{}
Функцията SystemClock\_Config() настройва синхронизиращите сигнали. Повтаря вече направената конфигурация на основния тактов сигнал и го подава на периферните модули. Конфигурира 8MHz тактов сигнал за аналогово-цифровия преобразувател (АЦП), получен от вътрешния осцилатор с честота 4MHz умножена по 16 от PLL и разделена на 8.\\
\indent{}
MX\_GPIO\_Init() настройва режимите на пиновете. Пиновете, свързани към светодиодите LED0÷LED11 (виж принципната схема "Конектори и индикация" към глава \ref{boards_chapter}), A0÷A2, ENABLE (A3), D0÷D3, \textoverline{IOR} и \textoverline{IOW} са изходни. По подразбиране пинове A0÷A2, \textoverline{IOR} и \textoverline{IOW} се установяват във високо ниво, а другите в ниско. Пинове D4÷D7 и пиновете, свързани с джойстиците са входни. Пиновете, свързани към SW1, също са входни и използват вградените в микроконтролера установяващи съпротивления.\\
\indent{}
Configure\_DMA() функцията настройва блока за директен достъп до паметта (DMA). Когато аналогово-цифровият преобразувател завърши конвертирането на входен сигнал се подава заявка към DMA модула. Стойността на изходния регистър на АЦП се копира от DMA на адрес в RAM, съответстващ на променливата pot\_vals (масив от четири 16-битови естествени числа). След всяка заявка адресът в паметта (елементът от масива) се инкрементира. След четвъртата заявка се връща на нулевия елемент от масива. Всичко това се извършва без намеса от страна на изчислителното ядро.\\
\indent{}
Следващата функция конфигурира параметрите на АЦП. Микроконтролерът разполага с 3 АЦП модула с общо 29 канала (някои от каналите са общи). Използват се четири канала от първия АЦП модул. Пиновете, свързани към потенциометрите, се настройват като аналогови входове. Използва се максималната разредност от 12 бита. Периодът на дискретизация e 92,5 пъти по-голям от периода на синхронизиращия сигнал.
\begin{align}
    T_s = 92,5 \frac{1}{f_c} = 92,5 \frac{1}{8\cdot10^6} &= 11,5625 \cdot 10^{-6} s \approx 11,5 \mu s\\
    f_s = \frac{1}{T_s} &\approx 86,5 kHz
\end{align}
Относително ниската честота на дискретизация е избрана заради времето, нужно за зареждането на кондензатора във входната верига на АЦП. Капацитетът на този кондензатор е 5pF \cite{mcu_specs} и се зарежда през потенциометрите в джойстиците. Съпротивленията на потенциометрите зависят от позициите им, но в най-лошия случай са $1M\Omega$. Това дава максимална времеконстанта:
\begin{equation}
    \tau = R \cdot C = 1 \cdot 10^{6} \cdot 5 \cdot 10^{-12} = 5 \cdot 10^{-6} = 5 \mu s
\end{equation}
АЦП модулът се конфигурира да обработва канали от 1 до 4 в нарастващ ред, повтаряйки тази поредица постоянно. Към пиновете, на които са изведени четирите канала, се свързват потенциометрите на джойстиците.\\
\indent{}
Функцията за инициализация на USART модула го настройва в асинхронен (UART) режим със скорост 115200 бода. Използва се един стоп бит, думата е осмебитова. Към нея се добавя един бит за четност, който е 1, ако в думата има четен брой единици. Пиновете RX и TX се настройват в алтернативен режим, което ги свързва към USART модула.\\
\indent{}
Функцията Activate\_ADC() извършва автоматична калибрация на АЦП модула и изчаква за завършването й. След това активира АЦП модула и проверява дали успешно се е задействал.\\
\indent{}
Следващата функция инициализира Data Watchpoint Trigger модула. Този блок предоставя функционалности, предназначени за дебъгване. Сред тях е брояч, инкрементиращ се при всеки такт на ядрото.
\cite{arm_arch}
Този брояч се използва от функцията DWT\_Delay() за засичане на време в $\mu s$.\\
\indent{}
След извикването на функцията LL\_ADC\_REG\_StartConversion() АЦП започва да извършва преобразувания според вече настроената последователност от канали 1÷4.\\
\indent{}
Функцията Enable\_Robko() подава разрешаващ сигнал към драйверната платка на робота като поставя пин ENABLE (A3) във високо ниво.\\
\indent{}
Регистрите на драйверната платка на робота се нулират чрез функцията stop\_motor() с параметър ALL. С това приключва инициализиращата част на програмата.\\
\indent{}
Основният цикъл започва с прочитане на състоянията на SW1. От тях зависят локалните настройки за режим пълна/полустъпка и скорост (виж \ref{manual_cntrl_section}), но командите за отдалечено управление, настройващи тези параметри, имат по-голяма тежест. Според състоянията на SW1 се определя дали да се извика функцията manual\_control() за ръчно управление или remote\_control() за отдалечено. След това се изпълнява функцията set\_LEDs(), която управлява светодиодите на основната платка и чрез тях показва в каква посока се движат моторите. В края на основния цикъл се изчаква моторите да се преместят до новите си позиции. Скоростта на въртене се регулира чрез продължителността на това изчакване.
\section{Ръчно управление}
Функцията за ръчно управление прочита състоянията на пиновете, свързани към бутоните на джойстиците, и ако са натиснати премества съответните мотори с по една стъпка в нужната посока. За управлението на моторите отговаря функцията step\_motor(), разгледана в точка \ref{motor_cntrl_section}. manual\_control() сравнява резултатите от последните преобразувания на АЦП модула с гранични стойности. Ако някои потенциометри са завъртяни достатъчно (дръжките на джойстиците са наклонени) съответните мотори се преместват с по една стъпка в нужната посока.
\section{Получаване на команди през серийна комуникация}
\label{cmd_recv_section}
Опашката от команди е реализирана като свързан списък от структури със следните елементи:
\begin{minted}
[
    baselinestretch=1.2,
    linenos,
    firstnumber=11
]
{C}
typedef struct cmd_buffer_t
{
	uint8_t cmd[13];
	uint8_t incomplete;
	struct cmd_buffer_t *next_cmd;
}
cmd_buffer_t;
\end{minted}
\indent{}
Когато се добавя нова команда към опашката се заделя динамично памет за нея чрез функцията malloc(). Масивът cmd[] съдържа номера на командата на нулева позиция и параметрите на командата (ако има такива) на следващите позиции. incomplete е флаг, който показва, че само част от командата е получена и преди да се пристъпи към изпълнението й трябва да се изчака USART модулът да получи и останалата част от командата. next\_cmd е указател към следващата команда. Ако командата е последна в опашката, стойността му е NULL. Няма указател към предишна команда - свързаният списък е еднопосочен.

При получаване на дума от USART модула се генерира прекъсване, което изпълнява функцията read\_cmd(). Блок схема на тази функция е показана на фигура \ref{fig:read_cmd}.
\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=1.5cm]
        \node (usart_read) [io] {Прочитане на 1B от USART};
        \node (rem_pos) [decision, below of = usart_read, yshift = -15mm, inner sep = 0.1cm] {rem\_bytes>0};
        \node (add_old) [process, below of = rem_pos, xshift = -50mm, yshift = -10mm] {\makecell{Добавяне към\\последната команда}};
        \node (priority) [decision, below of = rem_pos, xshift = 48mm, yshift = -10mm, inner sep = 0.1cm] {\makecell{Приоритетна\\команда?}};
        \node (current_incr) [process, below of = add_old, yshift = -2mm] {current\_byte++};
        \node (rem_decr) [process, below of = current_incr] {rem\_bytes-- --};
        \node (rem_zero) [decision, below of = rem_decr, yshift = -15mm, inner sep = 0.1cm] {rem\_bytes==0};
        \node (incompl_zero) [process, below of = rem_zero, yshift = -20mm] {incomplete=0};
        \node (exec) [process, below of = priority, yshift = -20mm] {Изпълнение};
        \node (current_one) [process, below of = priority, xshift = -45mm, yshift = 0mm] {current\_byte=1};
        \node (rem_n) [process, below of = current_one] {rem\_bytes=N};
        \node (maloc) [process, below of = rem_n, yshift = -2mm] {\makecell{Заделяне на\\динамична памет}};
        \node (add_new) [process, below of = maloc, yshift = -4mm] {\makecell{Добавяне към\\новата команда}};
        \node (incompl_one) [process, below of = add_new, yshift = -2mm] {incomplete=1};
        \draw [arrow] (usart_read) -- (rem_pos);
        \draw [arrow] (rem_pos) -| node [anchor = south west] {Да} (add_old);
        \draw [arrow] (rem_pos) -| node [anchor = south east] {Не} (priority);
        \draw [arrow] (add_old) -- (current_incr);
        \draw [arrow] (current_incr) -- (rem_decr);
        \draw [arrow] (rem_decr) -- (rem_zero);
        \draw [arrow] (rem_zero) -- node [anchor = west] {Да} (incompl_zero);
        \draw [arrow] (priority) -| node [anchor = south west] {Не} (current_one);
        \draw [arrow] (current_one) -- (rem_n);
        \draw [arrow] (rem_n) -- (maloc);
        \draw [arrow] (maloc) -- (add_new);
        \draw [arrow] (add_new) -- (incompl_one);
        \draw [arrow] (priority) -- node [anchor = west] {Да} (exec);
        \draw [arrow] ([shift = {(0mm, 20mm)}] usart_read.north) -- (usart_read);
        \draw [arrow_no_head] ([shift = {(-5mm, 5mm)}] usart_read.north) -- ([shift = {(5mm, 15mm)}] usart_read.north);
        \draw [arrow_no_head] (exec) |- ([shift = {(0mm, -7mm)}] incompl_zero.south) -- (incompl_zero);
        \draw [arrow] (incompl_one) -- ([shift = {(0mm, -40mm)}] incompl_one.south);
        \draw [arrow_no_head] ([shift = {(-5mm, -35mm)}] incompl_one.south) -- ([shift = {(5mm, -25mm)}] incompl_one.south);
        \draw [arrow] (rem_zero) -| node [anchor = south east] {Не} ([shift = {(30mm, -7mm)}] incompl_zero.south);
    \end{tikzpicture}
    \caption{Блок схема на функция read\_cmd()}
    \label{fig:read_cmd}
\end{figure}
Функцията започва с прочитане на получената осембитова дума. Извършва се проверка дали последната команда в опашката е напълно получена. Ако не е (rem\_bytes > 0), полученият байт се добавя към последната команда. Броят на получени байтове от последната команда (current\_byte) се инкрементира, а броят на оставащите байтове (rem\_bytes) се декрементира. Ако rem\_bytes е стигнал 0, флагът incomplete в последната команда се нулира.\\
\indent{}
Ако rem\_bytes е 0, това означава, че е получен първият байт от нова команда. Първият байт е номерът на командата и по него се определя каква команда се изпраща. Ако полученият байт съвпада с номера на приоритетна команда, веднага се пристъпва към изпълнението й. Това е възможно, понеже всички приоритетни команди се състоят от само един байт.\\
\indent{}
Командата за аварийно изключване KILL изключва всички мотори чрез изпълнението на stop\_motor(ALL), след което спира разрешаващия сигнал към робота - превключва пин ENABLE в ниско ниво. Команда RESUME подава раразрешаващия сигнал към робота - превключва пин ENABLE във високо ниво. При получаването на команда CLEAR се обхожда опашката от команди и се освобождава динамично заделената памет, което изтрива цялата опашка.\\
\indent{}
Ако командата не е приоритетна, трябва да се създаде нов елемент в опашката. current\_byte получава стойност 1, а rem\_bytes става равно на оставащите байтове от тази команда. Например за команда MOVE rem\_bytes първоначално е 12, а за команда OFF е 1. Виж таблица \ref{tab:commands} за дължините на командите. Памет за новата команда се заделя динамично чрез функцията malloc() и в нулевата позиция на масив cmd[] се записва полученият от USART байт. Ако командата се състои от повече от един байт се вдига флагът incomplete.
\section{Изпълнение на команди от опашката}
Опашката с команди се изпълнява от функцията за отдалечено управление - remote\_control. Блок схемата й е показана на фигура .
\begin{figure}
    \centering
    \begin{tikzpicture}[node distance=1.5cm]
        \node (start) [startstop] {Начало};
        \node (exists) [left of = start, decision, xshift = -40mm, inner sep = 0.1cm] {\makecell{Празна ли е\\опашката?}};
        \node (en) [below of = exists, decision, yshift = -35mm, inner sep = -0.1cm] {\makecell{Пин\\ENABLE e във\\високо ниво}};
        \node (incompl) [right of = en, decision, xshift = 40mm, inner sep = -0.2cm] {\makecell{Последната\\команда е получена\\докрай}};
        \node (exec) [below of = incompl, process, yshift = -25mm] {Изпълнение на командата};
        \node (compl) [below of = exec, decision, yshift = -17mm, inner sep = 0.1cm] {\makecell{Завършена ли\\е командата?}};
        \node (next) [below of = compl, process, yshift = -25mm] {\makecell{Преместване на указателя\\към текуща команда на следващата}};
        \node (rm) [below of = next, process, yshift = -2mm] {Изтриване на изпълнената команда};
        \node (end) [below of = rm, startstop] {Край};
        \draw [arrow] (start) -- (exists);
        \draw [arrow] (exists) -| node [anchor = south west] {Да} ([shift = {(-70mm, 0mm)}] end.west) -- (end);
        \draw [arrow] (exists) -- node [anchor = east] {Не} (en);
        \draw [arrow] (en) -- node [anchor = south] {Да} (incompl);
        \draw [arrow] (en) -- node [anchor = north east] {Не} ([shift={(0mm, -10mm)}] en.south) -- ([shift={(0mm, -124mm)}] en.south);
        \draw [arrow] (incompl) -- node [anchor = east] {Да} (exec);
        \draw [arrow] (incompl) -| node [anchor = south east] {Не} ([shift = {(30mm, 0mm)}] end.east) -- (end);
        \draw [arrow] (exec) -- (compl);
        \draw [arrow] (compl) -- node [anchor = east] {Да} (next);
        \draw [arrow] (compl) -- node [anchor = south] {Не} ([shift = {(-34mm, 0mm)}] compl.west);
        \draw [arrow] (next) -- (rm);
        \draw [arrow] (rm) -- (end);
    \end{tikzpicture}
    \caption{Блок схема на функция remote\_control()}
    \label{fig:remote}
\end{figure}
Функцията започва с проверки. Ако опашката е празна, не е подаден разрешаващ сигнал към робота или текущата команда не е изцяло получена, функцията завършва без да изпълни команда. В противен случай се преминава към изпълнението на текущата команда - най-старата в опашката. Изпълнението зависи от конкретната команда. Когато текущата команда бъде завършена се вдига флаг. Командите за движение се изпълняват за различен брой извиквания на remote\_control(), а другите команди за едно извикване на функцията. В края на функцията за отдалечено управление се проверява флага за завършена команда. Ако е вдигнат, указателят към текущата команда се измества с една позиция напред в опашката, а изпълнената команда се изтрива, като заделената й памет се освобождава чрез функцията free().\\
\indent{}
При изпълнението на команда MOV първо се проверява знака на втория параметър на командата. Ако е подаден положителен брой стъпки се извършва една стъпка напред на избрания мотор и броят стъпки се декрементира. При отрицателен брой стъпки се извършва стъпка назад и броят стъпки се инкрементира. Ако броят стъпки стигне 0 се вдига флагът за завършена команда. Чрез функцията check\_opto\_flag(), разгледана в точка \ref{opto_cmd_section}, се проверява дали командата трябва да се прекрати поради сигнал от оптичния сензор и ако трябва, се вдига флагът за завършена команда.\\
\indent{}
Команда MOVE действа подобно на MOV. Разликата е, че основният алгоритъм на команда MOV се повтаря шест пъти - по веднъж за всеки мотор. Флагът за завършена команда се вдига когато всички шест параметъра на командата стигнат нула или когато проверката с check\_opto\_flag() прекрати изпълнението на командата.\\
\indent{}
Изпълняването на следващите команди винаги вдига флага за завършена команда. Команда OFF извиква функцията stop\_motor() с параметъра, който й е подаден. Команда FREEZE спира разрешаващия сигнал към робота - пин ENABLE преминава в ниско ниво. При изпълнението на командите OPTO, SET\_STEP и SET\_SPEED параметърът им се запаметява в променлива.
\section{Управление на моторите}
\label{motor_cntrl_section}
Записването на стойности в регистрите на РОБКО 01 се извършва от функциите stop\_motor() и step\_motor(). stop\_motor() приема като параметър номера на мотор, който трябва да бъде изключен, и нулира регистъра му. Извикването й с параметър ALL нулира регистрите на всички мотори.\\
\indent{}
Функцията step\_motor() придвижва даден мотор с една стъпка. За всеки мотор има брояч, отмерващ колко стъпки е изминал. Таблица \ref{tab:step_order} е въведена в програмата като двуизмерен масив. Функцията step\_motor() инкрементира или декрементира брояча за избрания мотор според посоката в която трябва да направи стъпка (инкрементира се за права посока). В режим на пълна стъпка се инкрементира/декрементира с 2, а в режим на полустъпка с 1. Стойността на брояча се дели на 8 и се изчислява абсолютната стойност на остатъка. Резултатът е реда от таблица \ref{tab:step_order}, който съдържа нужната стойност на регистъра на мотора за да се премести на следващата стъпка. Посоката, в която се придвижва мотора, се записва, за да бъде използвана по-късно от функцията set\_LEDs().\\
\indent{}
Функциите stop\_motor() и step\_motor() използват функцията set\_addr(), която получава като параметър адрес на регистър в робота (номер на мотор) и позволява достъпа до него като настройва пиновете A0÷A2 в нужните състояния.
\section{Засичане на предмети с оптичен сензор}
\label{opto_cmd_section}
Функцията check\_opto\_flag() прочита третия бит от втория входен буфер на робота (адрес 7, \textoverline{IOR} в ниско ниво). Към него е свързан оптичния сензорен хващач. Според състоянието на оптичния сензор и променливата, съхраняваща последно получения режим на командата OPTO, определя дали трябва изпълняваната в момента команда да бъде прекратена.